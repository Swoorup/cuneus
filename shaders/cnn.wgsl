// CNN-based digit recognition, Enes Altun, 2025 MIT License
// I took the pre-trained values from: https://www.shadertoy.com/view/msVXWD: kishimisu, 2023. Shadertoy, default license.
// My code is Under MIT License, but the weights are from kishimisu. So please be aware of that.

struct TimeUniform {
    time: f32,
    delta: f32,
    frame: u32,
    _padding: u32,
};
@group(0) @binding(0) var<uniform> time_data: TimeUniform;

struct CNNParams {
    canvas_size: f32,       
    brush_size: f32,        
    input_resolution: f32,  
    clear_canvas: i32,      
    show_debug: i32,        
    prediction_threshold: f32, 
    canvas_offset_x: f32,   
    canvas_offset_y: f32,
    feature_maps_1: f32,    
    feature_maps_2: f32,    
    num_classes: f32,       
    normalization_mean: f32,
    normalization_std: f32,
    show_frequencies: i32,
    conv1_pool_size: f32,
    conv2_pool_size: f32,
}
@group(1) @binding(0) var<uniform> params: CNNParams;

struct MouseUniform {
    position: vec2<f32>,         
    click_position: vec2<f32>,   
    wheel: vec2<f32>,            
    buttons: vec2<u32>,          
};
@group(1) @binding(1) var<uniform> mouse: MouseUniform;

@group(2) @binding(0) var input_texture: texture_2d<f32>;
@group(2) @binding(1) var input_sampler: sampler;
@group(2) @binding(2) var output_texture: texture_storage_2d<rgba16float, write>;

@group(3) @binding(0) var<storage, read_write> canvas_data: array<f32>;      
@group(3) @binding(1) var<storage, read_write> conv1_data: array<f32>;       
@group(3) @binding(2) var<storage, read_write> conv2_data: array<f32>;       
@group(3) @binding(3) var<storage, read_write> fc_data: array<f32>;

struct FontUniforms {
    atlas_size: vec2<f32>,
    char_size: vec2<f32>,
    screen_size: vec2<f32>,
    _padding: vec2<f32>,
};
@group(1) @binding(2) var<uniform> u_font: FontUniforms;
@group(1) @binding(3) var t_font_atlas: texture_2d<f32>;
@group(1) @binding(4) var s_font_atlas: sampler;          

const INPUT_SIZE: u32 = 28u;
const CONV1_SIZE: u32 = 12u;  
const CONV2_SIZE: u32 = 4u;   
const FEATURE_MAPS_1: u32 = 8u;
const FEATURE_MAPS_2: u32 = 5u;
const NUM_CLASSES: u32 = 10u;

fn relu(x: f32) -> f32 {
    return max(0.0, x);
}

fn normalize_input(value: f32) -> f32 {
    return (value - params.normalization_mean) / params.normalization_std;
}

//please see compute_basic.wgsl for the font comments
fn render_char_sdf(pos: vec2<f32>, char_pos: vec2<f32>, ascii: u32, size: f32) -> f32 {
    let char_size = vec2<f32>(size, size);
    let local_pos = pos - char_pos;
    if (local_pos.x < 0.0 || local_pos.x >= char_size.x || 
        local_pos.y < 0.0 || local_pos.y >= char_size.y) {
        return 0.0;
    }
    let char_x = ascii % 16u;
    let char_y = ascii / 16u;
    let uv_local = local_pos / char_size;
    let atlas_size = 1024.0;
    let cell_size = 64.0;
    let padding = 4.0;
    let effective_cell_size = cell_size - padding * 2.0;
    let cell_uv = (padding + uv_local * effective_cell_size) / atlas_size;
    let char_offset = vec2<f32>(f32(char_x), f32(char_y)) * cell_size / atlas_size;
    let final_uv = char_offset + cell_uv;
    if (final_uv.x < 0.0 || final_uv.x >= 1.0 || 
        final_uv.y < 0.0 || final_uv.y >= 1.0) {
        return 0.0;
    }
    let atlas_coord = vec2<i32>(i32(final_uv.x * atlas_size), i32(final_uv.y * atlas_size));
    let pixel = textureLoad(t_font_atlas, atlas_coord, 0);
    return pixel.a;
}
fn render_digit(pos: vec2<f32>, char_pos: vec2<f32>, digit: u32, size: f32) -> f32 {
    return render_char_sdf(pos, char_pos, digit + 48u, size);
}


fn canvas_index(x: i32, y: i32) -> u32 {
    return u32(y * i32(INPUT_SIZE) + x);
}

fn conv1_index(x: i32, y: i32, fmap: i32) -> u32 {
    return u32(fmap * i32(CONV1_SIZE * CONV1_SIZE) + y * i32(CONV1_SIZE) + x);
}

fn conv2_index(x: i32, y: i32, fmap: i32) -> u32 {
    return u32(fmap * i32(CONV2_SIZE * CONV2_SIZE) + y * i32(CONV2_SIZE) + x);
}

fn screen_to_canvas(p: vec2<f32>, res: vec2<f32>) -> vec2<i32> {
    let q = vec2(p.x, 1.-p.y);
    let start = vec2(params.canvas_offset_x, params.canvas_offset_y);
    let end = start + params.canvas_size;
    if any(q < start) || any(q > end) { return vec2(-1); }
    let rel = (q - start) / params.canvas_size * params.input_resolution;
    return min(vec2<i32>(rel), vec2(i32(params.input_resolution - 1.)));
}


fn sample_canvas(pos: vec2<i32>) -> f32 {
    if (pos.x < 0 || pos.x >= i32(INPUT_SIZE) || pos.y < 0 || pos.y >= i32(INPUT_SIZE)) {
        return 0.0;
    }
    return canvas_data[canvas_index(pos.x, pos.y)];
}

fn sample_conv1(pos: vec2<i32>, fmap: i32) -> f32 {
    if (pos.x < 0 || pos.x >= i32(CONV1_SIZE) || pos.y < 0 || pos.y >= i32(CONV1_SIZE) || fmap < 0 || fmap >= i32(FEATURE_MAPS_1)) {
        return 0.0;
    }
    return conv1_data[conv1_index(pos.x, pos.y, fmap)];
}

//Conv Layer 1 weights (8 feature maps, each with 5x5 kernel + bias)
fn get_conv1_weight(feature_map: i32, kernel_idx: i32) -> f32 {
    if (feature_map == 0) {
        let weights = array<f32, 25>(
            -0.256220, -0.263963, -0.222650, -0.121450, 0.008962,
            -0.286535, -0.128346, -0.119005, -0.105653, 0.106190,
            -0.196784, 0.015316, 0.154883, 0.169439, 0.155174,
            -0.088119, 0.207242, 0.153355, 0.170941, 0.058379,
            0.179226, 0.170095, 0.187621, 0.115604, 0.211174
        );
        return weights[kernel_idx];
    } else if (feature_map == 1) {
        let weights = array<f32, 25>(
            -0.208491, -0.246941, -0.118710, 0.029216, 0.134078,
            0.175747, 0.050075, -0.259553, -0.155585, -0.184678,
            0.216247, 0.372172, 0.049592, -0.160362, 0.087013,
            -0.088406, 0.108477, 0.387428, 0.045766, 0.116031,
            -0.219892, -0.266197, 0.089884, 0.015118, 0.100712
        );
        return weights[kernel_idx];
    } else if (feature_map == 2) {
        let weights = array<f32, 25>(
            -0.152888, 0.072108, 0.141602, 0.300121, -0.126745,
            -0.232032, -0.066877, 0.099079, 0.214114, 0.106322,
            -0.143861, -0.108627, 0.071171, 0.197545, 0.184703,
            -0.112155, -0.106069, -0.093000, 0.101620, 0.161687,
            -0.083832, -0.058263, -0.031437, 0.034528, 0.223640
        );
        return weights[kernel_idx];
    } else if (feature_map == 3) {
        let weights = array<f32, 25>(
            0.127065, 0.067651, 0.237392, 0.122720, 0.263380,
            0.272143, 0.229455, 0.201271, 0.158494, 0.083364,
            0.087063, 0.005914, -0.107822, 0.037689, -0.241690,
            -0.144014, -0.320903, -0.222353, -0.283808, -0.332431,
            -0.049706, -0.170751, -0.223001, -0.079481, 0.056033
        );
        return weights[kernel_idx];
    } else if (feature_map == 4) {
        let weights = array<f32, 25>(
            0.033839, 0.143132, -0.216749, -0.075409, -0.010285,
            0.097860, 0.241089, 0.214650, -0.225313, -0.184724,
            -0.270974, -0.187646, 0.235756, 0.272372, -0.101422,
            -0.151017, 0.042975, -0.064422, 0.240397, -0.020506,
            0.119857, -0.080291, -0.152493, -0.076686, 0.018775
        );
        return weights[kernel_idx];
    } else if (feature_map == 5) {
        let weights = array<f32, 25>(
            -0.408473, -0.134044, -0.069418, 0.135106, 0.173311,
            -0.176028, -0.379614, -0.162828, -0.082388, -0.015580,
            -0.027795, -0.173466, -0.435070, -0.292225, -0.234535,
            0.202488, 0.089885, -0.082089, -0.095222, -0.332411,
            0.152386, 0.277061, 0.114890, 0.061884, -0.197509
        );
        return weights[kernel_idx];
    } else if (feature_map == 6) {
        let weights = array<f32, 25>(
            -0.160558, -0.262113, 0.070456, 0.071991, 0.223662,
            -0.250266, -0.110144, -0.006879, 0.095233, 0.134715,
            -0.217089, -0.253514, -0.046932, 0.212780, 0.138915,
            -0.067716, -0.162607, -0.162463, -0.006180, 0.204881,
            -0.164372, -0.196290, -0.336171, -0.003429, 0.090525
        );
        return weights[kernel_idx];
    } else if (feature_map == 7) {
        let weights = array<f32, 25>(
            0.314642, 0.069870, -0.232515, -0.196920, -0.258605,
            0.182785, -0.227795, -0.121011, -0.160892, -0.082476,
            0.000842, -0.182144, -0.192695, -0.022503, -0.187570,
            -0.158919, -0.226402, -0.036234, 0.014082, -0.162542,
            -0.310638, -0.177386, -0.002980, -0.114051, -0.113300
        );
        return weights[kernel_idx];
    }
    return 0.0;
}

fn get_conv1_bias(feature_map: i32) -> f32 {
    let biases = array<f32, 8>(
        0.026794, 0.024362, -0.389324, -0.100076, -0.021946, 0.094496, -0.214098, 0.144752
    );
    return biases[feature_map];
}

//Conv Layer 2 weights (5 output feature maps, 8 input feature maps, 5x5 kernels each)
fn get_conv2_weight(output_fmap: i32, input_fmap: i32, kernel_idx: i32) -> f32 {
    // Output Feature Map 0
    if (output_fmap == 0) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.046534, -0.073340, -0.104696, -0.128232, -0.058648,
                -0.096220, -0.058887, -0.051275, -0.135895, -0.095000,
                0.021992, 0.008313, -0.001602, -0.100098, -0.076632,
                0.074367, 0.046224, 0.047301, -0.039357, -0.088746,
                -0.022489, -0.013636, 0.026681, -0.035710, -0.047739
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                0.164134, 0.110662, -0.037616, -0.125064, -0.127855,
                0.073158, 0.050712, -0.040878, -0.127835, -0.127839,
                -0.017567, -0.023066, -0.121369, -0.149846, -0.128354,
                -0.002525, -0.038398, -0.063718, -0.087393, -0.119930,
                -0.008945, 0.011088, -0.008347, -0.025335, -0.090066
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                0.105954, 0.068219, 0.052490, 0.059224, 0.077750,
                0.096263, 0.074264, 0.048235, 0.092739, 0.073469,
                0.032869, 0.095552, 0.097416, 0.096990, 0.111675,
                0.016135, 0.048912, 0.076057, 0.040083, 0.111671,
                0.062053, 0.030614, 0.042673, 0.015659, -0.054323
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                0.004916, -0.063013, -0.071405, -0.037116, 0.002900,
                -0.057140, -0.132976, -0.109345, -0.126376, -0.090146,
                -0.072674, -0.033938, -0.056043, -0.173670, -0.207806,
                -0.030818, 0.016815, -0.042149, -0.167785, -0.189784,
                -0.013633, 0.030919, -0.033668, -0.096383, -0.144897
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.133044, 0.078342, -0.021171, -0.039290, -0.146281,
                0.059153, 0.065948, -0.078621, -0.080518, -0.103001,
                0.026036, 0.026372, -0.058402, -0.017815, -0.025400,
                0.019300, 0.019241, -0.021274, 0.035523, 0.018338,
                0.083902, -0.007695, -0.036464, -0.009007, -0.055234
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.192597, 0.108261, 0.024767, 0.030960, -0.021334,
                0.024290, 0.086279, -0.003715, -0.018433, -0.032012,
                -0.074780, 0.007053, -0.009388, 0.038558, 0.067052,
                -0.160614, -0.032528, 0.063304, 0.005934, 0.048658,
                -0.018971, 0.061493, 0.078854, 0.110024, 0.083818
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.003607, 0.026321, 0.060368, 0.036074, 0.171541,
                0.032160, 0.089552, 0.114002, 0.135316, 0.164947,
                0.029636, 0.102024, 0.157455, 0.134793, 0.202357,
                0.053904, 0.043092, 0.043481, 0.042083, 0.038933,
                0.065984, 0.022676, -0.006638, -0.040437, -0.006689
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                -0.148014, -0.131265, -0.006657, 0.028222, 0.059049,
                -0.088015, -0.044709, 0.008072, 0.089204, 0.032808,
                0.034581, 0.050597, 0.079305, 0.068517, -0.010634,
                0.015563, 0.152927, 0.181252, 0.039751, 0.100112,
                0.027230, 0.100313, 0.128368, 0.128317, 0.169261
            );
            return weights[kernel_idx];
        }
    }
    // Output Feature Map 1
    else if (output_fmap == 1) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                0.168473, 0.032020, 0.080606, 0.144209, 0.231596,
                0.079855, 0.003243, -0.009647, 0.048977, 0.097265,
                -0.072842, -0.098611, -0.112680, -0.060538, -0.056511,
                -0.103706, -0.094244, -0.127457, -0.089937, -0.037145,
                0.136340, 0.058937, -0.078355, -0.123603, -0.098124
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                -0.024345, -0.065386, -0.066836, 0.031687, 0.098069,
                0.086487, 0.033651, 0.040699, 0.055580, 0.070794,
                0.086650, 0.063994, 0.065869, 0.089419, 0.060025,
                -0.023042, -0.027093, 0.019867, 0.046299, 0.117471,
                0.039959, -0.012688, -0.050492, 0.038449, 0.067053
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                -0.027017, -0.127440, -0.171092, -0.129185, -0.076406,
                -0.017304, 0.018061, -0.080205, -0.125497, -0.040958,
                0.052195, 0.109802, 0.033683, 0.025611, -0.034670,
                0.028702, 0.125819, 0.089908, 0.069893, -0.003656,
                -0.058450, -0.017720, 0.019981, -0.024931, -0.032475
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                -0.061035, 0.061276, 0.113922, 0.197254, 0.130410,
                -0.031010, -0.154345, -0.095403, 0.088329, 0.161673,
                -0.033375, -0.160063, -0.197056, -0.179653, -0.062698,
                0.046245, -0.054445, -0.112475, -0.129480, -0.065540,
                0.007957, 0.003427, 0.009232, -0.005896, 0.022805
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                -0.070249, -0.085293, -0.033846, -0.002253, 0.170257,
                0.021667, 0.018398, -0.070920, 0.013574, 0.094702,
                0.098059, 0.163548, 0.151802, 0.081656, 0.102940,
                0.051876, 0.170479, 0.141152, 0.148914, 0.167806,
                0.011094, 0.130688, 0.115504, 0.151504, 0.114944
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.040850, -0.090765, -0.123967, -0.145776, -0.089269,
                0.041644, 0.016847, -0.085726, -0.143723, -0.142347,
                0.055868, 0.071702, 0.010950, -0.033863, -0.115396,
                -0.034491, -0.016859, -0.003221, 0.029593, 0.055885,
                -0.021719, -0.088430, -0.045182, -0.036528, -0.000889
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                -0.045231, -0.020948, -0.155331, -0.198503, -0.212880,
                -0.022472, 0.073340, 0.054503, -0.092496, -0.186318,
                -0.016517, 0.083499, 0.099173, 0.082856, -0.058938,
                -0.026629, 0.041044, 0.056476, 0.039056, 0.017643,
                -0.082308, -0.057666, -0.053039, -0.028161, -0.017550
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                0.057026, 0.055334, 0.153768, 0.078982, 0.143101,
                -0.047424, -0.015665, -0.013397, 0.002743, 0.061596,
                -0.063201, -0.017605, -0.060343, -0.056431, -0.013590,
                -0.022667, 0.011825, -0.042425, -0.148410, -0.080338,
                -0.044272, 0.107271, 0.148680, 0.082134, -0.009649
            );
            return weights[kernel_idx];
        }
    }
    // Output Feature Map 2
    else if (output_fmap == 2) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                0.064619, -0.002426, 0.033947, 0.044316, 0.115687,
                0.053022, 0.065041, 0.066363, 0.073362, 0.040481,
                -0.053032, 0.086060, 0.069675, 0.034031, 0.030123,
                0.021665, -0.060047, -0.090843, 0.005910, 0.192376,
                -0.167963, -0.160012, -0.120027, 0.010712, 0.100215
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                0.031789, 0.080503, 0.040288, 0.009264, 0.049026,
                0.095390, 0.100852, 0.003961, -0.014274, -0.038138,
                0.061696, 0.101006, 0.027643, -0.047844, -0.048016,
                -0.077837, -0.095082, -0.145615, -0.099213, -0.044476,
                -0.134099, -0.114614, -0.105741, -0.051032, 0.076231
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                -0.033284, -0.048057, -0.050669, -0.023352, -0.044807,
                -0.032219, -0.009562, 0.003693, 0.044597, 0.040209,
                -0.022571, -0.045959, -0.114624, -0.064666, -0.033394,
                -0.060179, -0.132713, -0.120706, -0.112588, -0.064358,
                -0.137772, -0.115105, -0.073647, -0.000281, 0.030574
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                -0.118146, -0.095420, -0.058021, -0.016661, -0.014902,
                0.040134, 0.011013, 0.116889, 0.098456, 0.146382,
                0.115527, 0.098948, 0.132890, 0.074907, 0.059989,
                0.067840, -0.003165, 0.103561, 0.104807, 0.111656,
                0.156925, 0.045268, 0.018593, -0.069436, -0.049523
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.011728, 0.040852, 0.000240, -0.038427, -0.041976,
                -0.004255, 0.019583, 0.026010, 0.004745, -0.038317,
                0.002854, -0.036712, 0.026922, -0.005803, -0.110613,
                -0.035845, 0.022496, -0.012490, -0.087088, -0.068759,
                -0.026644, -0.063738, -0.021046, -0.010263, -0.051859
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.110702, 0.117118, 0.138851, 0.014485, -0.029469,
                0.102581, 0.112743, 0.125491, 0.069034, 0.028476,
                0.019210, -0.007038, -0.054246, -0.028243, -0.069148,
                0.042524, -0.052357, -0.005603, -0.055190, -0.034142,
                -0.022592, 0.026197, 0.019640, -0.063740, 0.017314
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.003538, -0.035311, -0.035084, -0.022011, -0.042928,
                -0.008708, 0.019993, -0.008411, -0.053142, -0.093495,
                -0.087310, -0.042563, -0.083762, -0.084108, -0.095313,
                -0.109650, -0.156403, -0.100507, -0.030987, -0.052391,
                -0.115120, -0.115170, 0.005497, 0.009972, 0.064793
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                -0.029818, -0.073513, -0.021365, 0.038191, -0.053594,
                0.001866, -0.106707, -0.135535, -0.090814, 0.005511,
                -0.072168, -0.092473, 0.030897, 0.044974, 0.017658,
                0.098985, 0.078218, 0.025579, 0.027096, 0.056002,
                0.109690, 0.114611, 0.064988, 0.029201, -0.029181
            );
            return weights[kernel_idx];
        }
    }
    // Output Feature Map 3
    else if (output_fmap == 3) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.065041, -0.044827, -0.045408, -0.027479, -0.016581,
                -0.113267, -0.034325, -0.067802, -0.019938, -0.008703,
                -0.003708, 0.025421, 0.018985, 0.013058, -0.022186,
                0.074049, 0.122886, 0.084369, 0.107888, 0.004665,
                0.177412, 0.168101, 0.157727, 0.035967, -0.169895
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                0.094543, 0.121074, 0.071699, 0.048749, 0.077483,
                0.050495, 0.062031, 0.092835, 0.042366, -0.018972,
                0.031505, 0.065801, 0.005604, -0.043289, -0.050872,
                -0.012502, 0.039254, 0.035616, -0.093267, -0.114860,
                0.109167, 0.041145, 0.025472, -0.034760, -0.068790
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                0.074297, 0.107164, 0.038573, 0.018497, -0.066989,
                0.045576, 0.043657, 0.064087, 0.037835, -0.016352,
                -0.004218, 0.015408, 0.042173, 0.078353, 0.014127,
                0.021499, -0.003591, 0.021562, 0.030094, -0.077727,
                -0.043636, -0.038942, 0.041748, 0.021877, -0.089420
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                -0.025842, -0.024335, -0.034287, -0.035360, 0.001802,
                0.018795, 0.002706, -0.062916, -0.121407, -0.060586,
                -0.051345, -0.001345, -0.131490, -0.040997, -0.003273,
                -0.048635, 0.047884, 0.027771, 0.022292, 0.015396,
                -0.082129, 0.025646, 0.064377, 0.022169, 0.098010
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.023513, 0.081035, 0.050733, 0.038003, -0.023454,
                0.021369, 0.075130, 0.023919, 0.010114, -0.046117,
                0.038494, 0.071608, 0.054695, 0.017425, -0.019284,
                -0.024073, -0.025879, -0.032753, -0.007604, -0.005919,
                -0.022793, -0.027887, 0.023217, 0.056594, -0.005012
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.145032, 0.115085, 0.068654, -0.015920, 0.008778,
                0.137004, 0.114580, 0.112755, -0.015727, -0.019876,
                0.114773, 0.001262, -0.060381, -0.203856, -0.173244,
                -0.027702, -0.130193, -0.220279, -0.297398, -0.198849,
                0.036194, -0.086494, -0.231162, -0.261053, -0.139979
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.051161, 0.028729, 0.026783, 0.109775, 0.048805,
                -0.032467, -0.027144, 0.034998, 0.090104, 0.017593,
                -0.070456, -0.112503, -0.021751, 0.052960, -0.030093,
                0.041898, -0.083327, -0.084202, -0.028898, -0.085812,
                0.006779, -0.005748, 0.023357, -0.028606, -0.105384
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                0.077756, -0.054394, -0.055692, -0.035044, -0.019320,
                0.055786, 0.011287, -0.020608, -0.057911, -0.028529,
                0.066594, 0.144801, 0.038596, 0.021778, 0.012389,
                0.015986, 0.062553, 0.152408, 0.034392, 0.143995,
                -0.057195, -0.097240, 0.051983, 0.045353, 0.025535
            );
            return weights[kernel_idx];
        }
    }
    // Output Feature Map 4
    else if (output_fmap == 4) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.151024, -0.085353, -0.020371, 0.038760, -0.017698,
                -0.146046, -0.083711, -0.046654, 0.045819, 0.086094,
                -0.099861, -0.173572, -0.204014, -0.150274, -0.153582,
                -0.139883, -0.050268, 0.151440, 0.127305, -0.059448,
                -0.017022, 0.141502, 0.131710, 0.131854, 0.132665
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                0.028596, 0.001047, -0.036430, -0.042759, -0.047757,
                0.008165, -0.015975, -0.116590, -0.035810, -0.025485,
                -0.116234, -0.083054, -0.144707, -0.098301, -0.066349,
                -0.088110, -0.064091, -0.054771, 0.074695, 0.067527,
                -0.006192, 0.032544, 0.078078, 0.200340, 0.234686
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                0.113024, 0.110267, 0.063846, 0.049881, 0.009695,
                0.100619, 0.063978, 0.018875, 0.029239, 0.006424,
                -0.139673, -0.104241, -0.064975, -0.035013, -0.037164,
                -0.241233, -0.229522, -0.180526, -0.114720, -0.077498,
                -0.180585, -0.059412, -0.062612, 0.002683, 0.002933
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                0.025844, -0.008108, 0.030224, 0.084082, -0.035616,
                0.042340, -0.088508, -0.012998, 0.068494, 0.095155,
                0.089146, 0.034854, 0.112012, 0.107305, 0.146836,
                0.077914, 0.031680, 0.100960, 0.038912, -0.046642,
                -0.052792, -0.119617, 0.066024, 0.048530, -0.066909
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.132893, 0.075638, -0.040484, -0.002135, -0.011319,
                0.073798, -0.033863, 0.013071, -0.068327, -0.034962,
                -0.018041, 0.051831, -0.003209, 0.045083, -0.023776,
                -0.010383, -0.048997, -0.023641, -0.003945, 0.008028,
                -0.041111, 0.000938, -0.051027, -0.017615, 0.055404
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                -0.004129, -0.031338, -0.051943, -0.041951, -0.032597,
                -0.048305, -0.066592, -0.038255, -0.064113, 0.055801,
                -0.074688, -0.049016, 0.044922, 0.068887, 0.146106,
                0.030208, -0.076818, 0.027783, 0.140470, 0.144964,
                0.049108, 0.020163, 0.121420, 0.205076, 0.226896
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.091393, 0.126330, 0.095413, -0.014538, -0.030099,
                0.013168, 0.041257, 0.029750, 0.073070, -0.086262,
                -0.078126, -0.132817, -0.086798, -0.036953, -0.040775,
                -0.191780, -0.112947, -0.109343, -0.150807, -0.148036,
                -0.017872, -0.029193, -0.024341, 0.008525, -0.054663
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                -0.080706, -0.014936, 0.009476, 0.022717, 0.089186,
                -0.055918, 0.047336, 0.101627, 0.111755, 0.058078,
                0.085592, 0.116362, 0.077001, 0.119588, 0.047873,
                0.111052, 0.068810, 0.062873, 0.089996, 0.017395,
                -0.049681, -0.073608, -0.052349, -0.055716, -0.013794
            );
            return weights[kernel_idx];
        }
    }
    
    return 0.0; 
}

fn get_conv2_bias(feature_map: i32) -> f32 {
    let biases = array<f32, 5>(0.015435, 0.035864, 0.044618, 0.005539, -0.083093);
    return biases[feature_map];
}

//weights (10 output classes, 80 inputs each)
fn get_fc_weight(class_idx: i32, input_idx: i32) -> f32 {
    // Class 0 weights
    if (class_idx == 0) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                -0.075143, -0.056622, -0.121313, 0.038140, 0.107850, 0.188001, 0.055559, -0.006876,
                0.001238, 0.081469, 0.061499, -0.014917, 0.090366, -0.058191, 0.039274, -0.097306,
                0.152312, -0.003635, 0.084143, 0.125680
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                0.092808, -0.042792, -0.217296, -0.008191, -0.016148, 0.040513, -0.097174, -0.288848,
                -0.039060, 0.055375, 0.026479, -0.100895, -0.080106, 0.108912, 0.155070, 0.070415,
                -0.210549, -0.061629, 0.051988, -0.081011
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                -0.035969, -0.020141, -0.061554, 0.046853, -0.003657, 0.052620, 0.024415, 0.029756,
                0.145766, -0.123348, -0.211711, -0.090868, 0.052405, -0.168870, 0.045629, 0.150798,
                -0.015225, 0.010330, 0.044918, 0.157409
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                -0.025917, 0.003875, 0.003508, 0.108845, -0.289601, 0.004226, -0.055828, -0.068674,
                -0.291888, 0.052395, 0.014539, -0.073194, -0.017768, -0.024752, 0.010479, -0.106618,
                0.088511, 0.022097, 0.028473, 0.014830
            );
            return weights[input_idx - 60];
        }
    }
    // Class 1 weights
    else if (class_idx == 1) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                0.118176, 0.307418, 0.035010, -0.127493, 0.127779, 0.149029, 0.094610, -0.073976,
                0.010956, 0.078971, 0.082320, 0.008612, 0.076737, 0.168552, 0.186871, -0.035339,
                -0.015820, 0.036516, -0.146051, -0.180930
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                -0.170593, -0.077640, 0.025629, -0.123664, -0.165897, -0.227003, -0.072458, -0.017666,
                -0.102989, -0.030075, -0.088207, 0.055515, 0.137357, 0.228489, 0.022315, 0.254441,
                -0.020429, 0.017245, -0.087207, 0.008994
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                0.023044, 0.044528, 0.069337, -0.039198, 0.076846, -0.057162, -0.143618, -0.169474,
                -0.177619, 0.025151, 0.033428, -0.101687, -0.147556, 0.020280, -0.051744, -0.066299,
                0.011121, 0.083689, -0.029114, -0.205382
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                0.036833, 0.025825, -0.043088, -0.131485, 0.181081, -0.172405, -0.000713, 0.102880,
                0.141426, 0.051331, -0.106324, 0.047509, 0.093582, -0.000411, -0.079680, -0.056620,
                -0.060069, 0.054039, -0.072068, -0.033597
            );
            return weights[input_idx - 60];
        }
    }
    // Class 2 weights
    else if (class_idx == 2) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                0.075104, -0.062261, -0.243282, -0.211665, 0.067593, 0.049483, 0.006165, -0.104614,
                -0.070173, 0.056063, 0.041839, 0.022482, -0.044319, -0.037660, 0.098334, 0.088488,
                0.187212, 0.098346, 0.135175, 0.002778
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                -0.002911, 0.052746, 0.057234, 0.060808, -0.081446, -0.102199, -0.116797, 0.039287,
                0.031106, 0.081425, -0.057470, -0.228619, -0.065109, -0.080685, 0.095244, 0.107105,
                0.127165, 0.022375, 0.155364, 0.155487
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                0.190379, 0.096634, -0.021882, 0.098712, 0.026928, 0.034139, 0.019663, -0.052137,
                -0.153903, -0.100958, 0.056287, -0.086529, -0.207472, -0.086102, 0.039555, -0.094216,
                -0.018086, 0.023409, 0.064830, 0.066338
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                0.020448, 0.145752, 0.130498, 0.108338, 0.000179, -0.044342, 0.028753, 0.132895,
                0.120966, 0.090906, -0.047338, -0.036944, 0.201408, 0.132772, 0.001545, -0.074028,
                0.065345, 0.026543, 0.014589, 0.012444
            );
            return weights[input_idx - 60];
        }
    }
    // Class 3 weights
    else if (class_idx == 3) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                -0.090207, -0.089532, 0.088258, 0.058080, 0.064625, -0.119222, 0.018076, 0.064042,
                -0.006809, -0.155456, -0.149699, -0.041605, -0.170260, -0.177147, 0.018428, 0.047750,
                -0.046373, -0.095485, 0.008783, 0.175543
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                -0.130315, -0.002828, 0.037634, -0.033963, -0.169322, -0.005636, 0.071235, 0.205786,
                -0.126502, -0.006692, 0.101685, 0.008342, 0.274166, 0.024771, 0.013405, 0.056795,
                0.131263, -0.104002, -0.045315, -0.075801
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                0.045826, -0.047754, -0.018996, 0.083615, 0.138966, 0.088836, 0.012930, 0.001248,
                -0.091140, 0.022401, 0.068219, 0.065187, -0.133591, -0.033201, 0.030706, 0.058613,
                -0.068666, 0.005972, 0.027504, -0.062614
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                0.031467, 0.142602, 0.144359, 0.099213, 0.154107, 0.130326, 0.009151, -0.029851,
                0.053593, 0.070038, -0.052174, 0.128651, 0.163541, 0.085602, -0.060960, -0.008063,
                -0.071249, -0.036413, -0.015864, 0.027310
            );
            return weights[input_idx - 60];
        }
    }
    // Class 4 weights
    else if (class_idx == 4) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                0.136695, 0.182818, 0.088052, -0.039925, -0.075844, -0.063367, -0.108014, -0.018086,
                -0.016628, 0.062744, -0.095771, 0.023198, 0.095606, 0.207663, 0.257984, 0.050648,
                -0.120700, -0.035294, -0.000187, -0.263116
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                0.238731, -0.057893, -0.049301, 0.094419, 0.145201, 0.049918, 0.015038, 0.188535,
                0.033250, 0.025587, 0.010658, 0.094547, -0.208576, -0.017720, 0.027217, -0.136156,
                0.057621, 0.095122, 0.049686, -0.050623
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                0.057528, 0.102234, -0.040277, -0.056215, -0.068852, -0.109990, -0.117830, -0.144675,
                0.127953, 0.057657, 0.086862, -0.095754, 0.144894, 0.062875, 0.099320, -0.072185,
                0.162736, -0.058694, -0.002515, -0.135430
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                0.072161, -0.046754, -0.110878, -0.080166, 0.154885, 0.071826, -0.033267, 0.041170,
                -0.037779, 0.082510, -0.084086, -0.254560, -0.260250, -0.118318, -0.200516, -0.217559,
                0.004250, 0.052013, -0.009852, -0.003096
            );
            return weights[input_idx - 60];
        }
    }
    // Class 5 weights
    else if (class_idx == 5) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                -0.178578, -0.033715, 0.062495, 0.123911, -0.079341, 0.031328, 0.149985, 0.108790,
                0.038392, 0.003860, -0.044916, -0.071479, 0.076275, -0.004897, -0.237388, -0.230086,
                -0.031948, -0.050418, -0.017694, 0.111659
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                -0.039834, -0.025885, -0.176076, -0.183601, 0.027238, -0.043208, -0.044587, -0.167072,
                0.077036, 0.070081, 0.041857, 0.004037, 0.214419, 0.019067, 0.095564, 0.148249,
                0.134796, -0.039023, 0.041526, 0.005519
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                -0.112477, 0.055217, 0.067744, 0.044419, -0.122010, 0.016899, 0.044329, 0.063331,
                -0.001170, -0.028405, 0.030677, 0.049971, 0.042898, -0.076075, 0.022667, 0.100927,
                0.034227, -0.115852, -0.045271, -0.131120
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                -0.008138, -0.096292, -0.225341, -0.307498, 0.201879, 0.121726, 0.031848, 0.067965,
                0.023252, 0.037581, 0.023188, 0.232835, -0.031391, 0.004997, 0.187920, 0.183176,
                -0.064285, -0.002638, 0.052543, -0.082024
            );
            return weights[input_idx - 60];
        }
    }
    // Class 6 weights
    else if (class_idx == 6) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                -0.057050, -0.134399, -0.122724, 0.064394, 0.152000, 0.019556, -0.031776, 0.052156,
                0.120772, 0.019357, -0.115102, -0.147379, 0.144365, 0.184400, 0.120577, -0.019055,
                0.079528, 0.057769, 0.057480, 0.174716
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                0.053453, 0.056713, 0.046551, 0.032610, -0.024766, 0.009873, 0.027833, -0.121777,
                0.013510, 0.102499, 0.162073, 0.072631, -0.205622, 0.027753, 0.091037, 0.137706,
                -0.183732, -0.047233, 0.046830, 0.028960
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                -0.140672, -0.056614, 0.043881, 0.193260, -0.102161, -0.208817, -0.029989, -0.065135,
                0.217860, -0.006298, -0.055235, -0.113672, 0.057800, -0.220906, -0.069267, 0.140712,
                -0.056603, -0.370280, -0.220436, 0.038400
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                0.030640, -0.147402, -0.168191, -0.072018, -0.313547, -0.158284, -0.113741, -0.166187,
                -0.227553, -0.054454, -0.016922, 0.154416, -0.079466, 0.002345, 0.173209, 0.188420,
                -0.089767, -0.142408, 0.083195, 0.138831
            );
            return weights[input_idx - 60];
        }
    }
    // Class 7 weights
    else if (class_idx == 7) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                0.147193, 0.231966, 0.095020, -0.021941, -0.015895, 0.098792, -0.064944, 0.028368,
                -0.136790, 0.175537, 0.016196, -0.011436, -0.031492, -0.118787, -0.043338, 0.017880,
                -0.221716, -0.069914, -0.040570, -0.206222
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                -0.126974, -0.234906, 0.035792, 0.030831, -0.134563, -0.213465, 0.049959, 0.099537,
                -0.079816, -0.178674, -0.040387, 0.037523, -0.199892, -0.095019, -0.164849, -0.186725,
                0.029778, -0.013067, -0.014325, 0.173757
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                0.129778, 0.101528, -0.001108, -0.035187, 0.130584, 0.126925, 0.099189, 0.093081,
                -0.153988, 0.038824, -0.056654, -0.262340, -0.112262, -0.117450, 0.019426, 0.059725,
                0.094022, 0.049326, 0.097184, 0.059849
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                -0.030705, 0.048778, 0.043639, 0.007166, 0.163268, -0.075866, -0.079359, 0.009316,
                0.137176, 0.078078, 0.059982, -0.152829, 0.149950, 0.121865, 0.041333, -0.092270,
                0.027952, 0.119484, 0.015529, 0.022465
            );
            return weights[input_idx - 60];
        }
    }
    // Class 8 weights
    else if (class_idx == 8) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                0.101581, -0.153697, 0.087488, 0.134878, 0.058520, -0.103262, -0.027637, 0.025659,
                0.027267, -0.168094, -0.074472, -0.056747, 0.033896, -0.106226, -0.103624, 0.036806,
                0.270243, 0.123119, -0.034506, 0.101094
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                -0.030633, 0.001415, 0.058839, 0.056024, 0.130417, -0.075567, 0.055068, 0.210288,
                0.208224, 0.107936, 0.080834, -0.075402, -0.089749, -0.095844, -0.007633, 0.024116,
                -0.082534, -0.040337, -0.038216, -0.191360
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                0.058365, -0.010573, -0.021778, 0.023169, -0.005684, 0.035098, 0.000621, 0.043171,
                0.036995, -0.024414, -0.004137, 0.111172, 0.171594, 0.115655, -0.067570, 0.011079,
                0.106235, 0.140141, -0.012020, 0.082657
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                -0.097238, 0.019621, 0.036329, 0.020079, -0.133260, -0.044889, 0.119676, 0.152850,
                -0.176713, -0.128383, -0.056316, 0.203849, -0.098394, -0.037967, 0.070011, 0.007828,
                -0.077018, -0.069563, -0.126146, -0.001432
            );
            return weights[input_idx - 60];
        }
    }
    // Class 9 weights
    else if (class_idx == 9) {
        if (input_idx < 20) {
            let weights = array<f32, 20>(
                -0.015266, 0.220139, 0.158281, -0.043156, -0.140757, -0.192276, 0.099127, 0.100479,
                0.083019, -0.081278, 0.040925, 0.026422, -0.016084, -0.155025, -0.070794, 0.061902,
                -0.219633, -0.134163, -0.024233, -0.090113
            );
            return weights[input_idx];
        } else if (input_idx < 40) {
            let weights = array<f32, 20>(
                0.140044, -0.128167, 0.021798, -0.015829, 0.158091, 0.027792, -0.006498, 0.047264,
                0.129774, 0.055528, 0.042968, -0.199966, 0.003728, 0.077743, -0.039579, -0.318130,
                -0.104920, 0.012678, 0.015643, -0.261913
            );
            return weights[input_idx - 20];
        } else if (input_idx < 60) {
            let weights = array<f32, 20>(
                -0.115093, -0.157660, -0.109066, 0.067627, -0.031246, 0.082480, 0.064080, 0.034145,
                0.079449, 0.015166, 0.038041, -0.036254, 0.080809, 0.096782, 0.078773, -0.034160,
                -0.155258, 0.041642, 0.051072, 0.096575
            );
            return weights[input_idx - 40];
        } else if (input_idx < 80) {
            let weights = array<f32, 20>(
                -0.323720, -0.105083, 0.060075, 0.020082, 0.161809, 0.179472, -0.093735, -0.048794,
                -0.066893, 0.111825, -0.136923, -0.050122, -0.233065, -0.025723, 0.110846, 0.062413,
                -0.007978, 0.001238, -0.011578, 0.110131
            );
            return weights[input_idx - 60];
        }
    }
    
    return 0.0;
}

fn get_fc_bias(class_idx: i32) -> f32 {
    let biases = array<f32, 10>(
        0.053830, 0.074264, 0.001615, -0.104617, 0.031150, -0.017540, 0.062103, 0.095845, -0.044117, 0.050840
    );
    return biases[class_idx];
}

@compute @workgroup_size(1, 1, 1)
fn canvas_update(@builtin(global_invocation_id) id: vec3<u32>) {
    let pos = vec2<i32>(id.xy);
    if any(pos >= vec2(i32(INPUT_SIZE))) { return; }
    
    let idx = canvas_index(pos.x, pos.y);
    let btns = mouse.buttons.x;
    
    if params.clear_canvas == 1 || (btns & 2u) != 0u {
        canvas_data[idx] = 0.;
        return;
    }
    
    if (btns & 1u) != 0u {
        let canvas_pos = screen_to_canvas(mouse.position, vec2<f32>(textureDimensions(output_texture)));
        if canvas_pos.x >= 0 {
            let dist = length(vec2<f32>(canvas_pos - pos));
            let radius = params.brush_size * params.input_resolution * 10.;
            let intensity = 1. - smoothstep(0., radius, dist);
            if intensity > 0. {
                canvas_data[idx] = min(1., canvas_data[idx] + intensity * .3);
            }
        }
    }
}

@compute @workgroup_size(1, 1, 1)
fn conv_layer1(@builtin(global_invocation_id) id: vec3<u32>) {
    let pos = vec3<i32>(id);
    if any(pos.xy >= vec2(i32(CONV1_SIZE))) || pos.z >= i32(FEATURE_MAPS_1) { return; }
    
    let pool_xy = pos.xy * 2;
    var max_val = -1000.;
    
    for (var d = 0; d < 4; d++) {
        let conv_xy = pool_xy + vec2(d & 1, d >> 1);
        var sum = get_conv1_bias(pos.z);
        
        for (var k = 0; k < 25; k++) {
            let kxy = vec2(k % 5, k / 5);
            let input_xy = conv_xy + kxy;
            let input_val = normalize_input(sample_canvas(input_xy));
            sum += input_val * get_conv1_weight(pos.z, k);
        }
        
        max_val = max(max_val, max(0., sum));
    }
    
    conv1_data[conv1_index(pos.x, pos.y, pos.z)] = max_val;
}

@compute @workgroup_size(1, 1, 1)
fn conv_layer2(@builtin(global_invocation_id) id: vec3<u32>) {
    let pos = vec3<i32>(id);
    if any(pos.xy >= vec2(i32(CONV2_SIZE))) || pos.z >= i32(FEATURE_MAPS_2) { return; }
    
    let pool_xy = pos.xy * 2;
    var max_val = -1000.;
    
    for (var d = 0; d < 4; d++) {
        let conv_xy = pool_xy + vec2(d & 1, d >> 1);
        var sum = get_conv2_bias(pos.z);
        
        for (var fm = 0; fm < i32(FEATURE_MAPS_1); fm++) {
            for (var k = 0; k < 25; k++) {
                let kxy = vec2(k % 5, k / 5);
                let input_xy = conv_xy + kxy;
                let input_val = sample_conv1(input_xy, fm);
                sum += input_val * get_conv2_weight(pos.z, fm, k);
            }
        }
        
        max_val = max(max_val, max(0., sum));
    }
    
    conv2_data[conv2_index(pos.x, pos.y, pos.z)] = max_val;
}

@compute @workgroup_size(1, 1, 1)
fn fully_connected(@builtin(global_invocation_id) id: vec3<u32>) {
    let class_idx = i32(id.x);
    if class_idx >= i32(NUM_CLASSES) { return; }
    
    var sum = get_fc_bias(class_idx);
    let conv2_size_sq = i32(CONV2_SIZE * CONV2_SIZE);
    
    for (var i = 0; i < i32(FEATURE_MAPS_2) * conv2_size_sq; i++) {
        let fmap = i / conv2_size_sq;
        let xy_idx = i % conv2_size_sq;
        let xy = vec2(xy_idx % i32(CONV2_SIZE), xy_idx / i32(CONV2_SIZE));
        let val = conv2_data[conv2_index(xy.x, xy.y, fmap)];
        sum += val * get_fc_weight(class_idx, i);
    }
    
    fc_data[class_idx] = sum;
}

@compute @workgroup_size(16, 16, 1)
fn main_image(@builtin(global_invocation_id) id: vec3<u32>) {
    let res = textureDimensions(output_texture);
    if any(id.xy >= res) { return; }
    
    let uv = vec2<f32>(f32(id.x), f32(res.y - id.y)) / vec2<f32>(res);
    var color = vec3(.02, .02, .05);
    
    let canvas_start = vec2(params.canvas_offset_x, params.canvas_offset_y);
    let canvas_end = canvas_start + params.canvas_size;
    
    if all(uv >= canvas_start) && all(uv <= canvas_end) {
        color = vec3(.1);
        
        let canvas_uv = (uv - canvas_start) / params.canvas_size;
        let canvas_coord = vec2<i32>(canvas_uv * params.input_resolution);
        
        if all(canvas_coord >= vec2(0)) && all(canvas_coord < vec2(i32(params.input_resolution))) {
            let val = sample_canvas(canvas_coord);
            color = mix(color, vec3(1.), val);
        }
        
        let border = .005;
        if any(uv < canvas_start + border) || any(uv > canvas_end - border) {
            color = vec3(.5);
        }
    }
    
    var predictions: array<f32, 10>;
    var max_logit = -1000.;
    
    for (var i = 0; i < i32(NUM_CLASSES); i++) {
        predictions[i] = fc_data[i];
        max_logit = max(max_logit, predictions[i]);
    }
    
    var exp_sum = 0.;
    for (var i = 0; i < i32(NUM_CLASSES); i++) {
        let exp_val = exp(predictions[i] - max_logit);
        predictions[i] = exp_val;
        exp_sum += exp_val;
    }
    
    let inv_sum = 1. / max(exp_sum, .001);
    for (var i = 0; i < i32(NUM_CLASSES); i++) {
        predictions[i] *= inv_sum;
    }
    
    let bar_start = vec2(.1, .75);
    let bar_dims = vec2(.06, .15);
    let bar_spacing = .08;
    
    if uv.y >= bar_start.y && uv.y <= bar_start.y + bar_dims.y {
        for (var digit = 0; digit < i32(NUM_CLASSES); digit++) {
            let bar_x = bar_start.x + f32(digit) * bar_spacing;
            
            if uv.x >= bar_x && uv.x <= bar_x + bar_dims.x {
                let confidence = predictions[digit];
                let bar_uv = (uv - vec2(bar_x, bar_start.y)) / bar_dims;
                
                color = vec3(.2);
                
                if bar_uv.y <= confidence {
                    color = mix(vec3(0., .5, 1.), vec3(1., .5, 0.), confidence) * (confidence * 3.);
                }
                
                var max_conf = 0.;
                var max_digit = 0;
                for (var i = 0; i < i32(NUM_CLASSES); i++) {
                    if predictions[i] > max_conf {
                        max_conf = predictions[i];
                        max_digit = i;
                    }
                }
                
                if digit == max_digit && max_conf > params.prediction_threshold {
                    let glow = sin(time_data.time * 3.) * .2 + .8;
                    color = mix(color, vec3(1., 1., 0.), .3 * glow);
                }
                
            }
        }
    }
    let pixel_pos = vec2<f32>(f32(id.x), f32(id.y));
    let font_bar_start_x = 0.1;
    let font_bar_spacing = 0.08;
    let font_bar_width = 0.06;
    let font_label_y = 0.1;
    
    for (var digit = 0; digit < i32(NUM_CLASSES); digit++) {
        let font_bar_x = font_bar_start_x + f32(digit) * font_bar_spacing;
        let digit_screen_pos = vec2<f32>(
            font_bar_x * f32(res.x) + font_bar_width * f32(res.x) * 0.5 - 16.0,
            font_label_y * f32(res.y)
        );
        let digit_alpha = render_digit(pixel_pos, digit_screen_pos, u32(digit), 32.0);
        color = mix(color, vec3(1.0), digit_alpha);
    }
    let mouse_corrected = vec2(mouse.position.x, 1. - mouse.position.y);
    let mouse_dist = distance(uv, mouse_corrected);
    if mouse_dist < .02 {
        let pulse = sin(time_data.time * 10.) * .5 + .5;
        color = mix(color, vec3(1.), .3 * pulse);
    }
    
    textureStore(output_texture, vec2<i32>(id.xy), vec4(pow(color, vec3(.8)), 1.));
}